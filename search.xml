<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STL</title>
      <link href="2021/02/17/c-c/stl/"/>
      <url>2021/02/17/c-c/stl/</url>
      
        <content type="html"><![CDATA[<p>STL： C++的标准模板库,包含一些常用的的算法和常用的数据结构，使用方便，效率较高。使用算法时，需要#include <algorithm>。</p><h2 id="STL中的sort排序"><a href="#STL中的sort排序" class="headerlink" title="STL中的sort排序"></a>STL中的sort排序</h2><p>对基本类型的数组从小到大排序：sort(数组名+n1, 数组名+n2);<br>对元素类型为T的基本类型数组从大到小排序。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123;    int arr[] &#x3D; &#123;23, 54, 12, 75, 43, 2&#125;;    int len &#x3D; sizeof(arr) &#x2F; sizeof(int);&#x2F;&#x2F;    sort(arr, arr+len); &#x2F;&#x2F;排序结果：2 12 23 43 54 75&#x2F;&#x2F;    sort(arr+2, arr+6); &#x2F;&#x2F;排序结果：23 54 2 12 43 75    sort(arr, arr+len, greater&lt;int&gt;()); &#x2F;&#x2F;排序结果：75 54 43 23 12 2    for (int i &#x3D; 0; i &lt; len; ++i) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用自定义的排序规则，对然后类型T的数组排序：sort(数组名+n1, 数组名+n2, 排序规则结构名());</p><p>排序规则结构的定义方式：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct 结构名&#123;    bool operator()(const T &amp; a1, const T &amp; a2) const &#123;        &#x2F;&#x2F;T：数据类型        &#x2F;&#x2F;若从大到小排序，则返回：a1 &gt; a2        &#x2F;&#x2F;若从小到大排序，则返回：a1 &lt; a2    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;cstring&gt;using namespace std;struct Student&#123;    char name[20];    int id;    double gpa;&#125;;Student student[] &#x3D; &#123;&#123;&quot;Tom&quot;, 23, 4.2&#125;, &#123;&quot;Jack&quot;, 34, 4.1&#125;&#125;;struct Rule1&#123; &#x2F;&#x2F;按照姓名从小到大排序    bool operator()(const Student &amp; s1, const Student &amp; s2) const &#123;        if(stricmp(s1.name, s2.name) &lt; 0) return true;        return false;    &#125;&#125;;struct Rule2&#123; &#x2F;&#x2F;按照id从小到大排序    bool operator()(const Student &amp; s1, const Student &amp; s2) const &#123;        return s1.id &lt; s2.id;    &#125;&#125;;struct Rule3&#123; &#x2F;&#x2F;按照gpa从高到低排序    bool operator()(const Student &amp; s1, const Student &amp; s2) const &#123;        return s1.gpa &lt; s2.gpa;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="STL中的二分查找算法"><a href="#STL中的二分查找算法" class="headerlink" title="STL中的二分查找算法"></a>STL中的二分查找算法</h2><p>STL提供在排好序的数组上进行二分查找的算法。</p><h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><p>binary_search(数组名+n1, 数组名+n2, 值)(如果找得到元素，则输出数据为1。如果找不到元素，则输出数据为0)。<br>【注】：binary_search可以用自定义排序规则排好序、元素为任意的T类型的数组中进行二分查找。结构为：binary_search(数组名+n1, 数组名+n2, 值, 排序规则结构名())</p><h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><p>T * lower_bound(数组名+n1, 数组名+n2, 值)(二分查找下界)。<br>返回一个指针T * p;  *p是查找区间下标最小的，大于等于“值”的元素。如果找不到，p指向下标为n2的元素。</p><h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h3><p>T * upper_bound(数组名+n1, 数组名+n2, 值)(二分查找上界)。<br>返回一个指针T * p;  *p是查找区间下标最小的，大于“值”的元素。如果找不到，p指向下标为n2的元素。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;void Print(int arr[], int n)&#123;    for (int i &#x3D; 0; i &lt; n; ++i) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;&#125;int main()&#123;    int arr[] &#x3D; &#123;34, 23, 56, 25, 12&#125;;    int len &#x3D; sizeof(arr)&#x2F;sizeof(int);    sort(arr, arr+len);    Print(arr, len);  &#x2F;&#x2F; 打印结果：12 23 25 34 56    cout &lt;&lt; endl;    cout &lt;&lt; binary_search(arr, arr+len, 23) &lt;&lt; endl; &#x2F;&#x2F; 打印结果：1    cout &lt;&lt; binary_search(arr, arr+len, 43) &lt;&lt; endl; &#x2F;&#x2F; 打印结果：0    int *p &#x3D; lower_bound(arr, arr+len, 23);    cout &lt;&lt; *p &lt;&lt; &quot;,&quot; &lt;&lt; p-arr &lt;&lt; endl; &#x2F;&#x2F;打印结果：23, 1    p &#x3D; upper_bound(arr, arr+len, 23);    cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F; 打印结果：25    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注】：STL中的平衡二叉树数据结构。”四种排序容器”：multiset   set   multimap  map</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单排序</title>
      <link href="2021/02/16/suan-fa/jian-dan-pai-xu/"/>
      <url>2021/02/16/suan-fa/jian-dan-pai-xu/</url>
      
        <content type="html"><![CDATA[<p>简单排序的量级都是 n^{2}</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>如果有N个元素需要排序，只需要找到最小的一个元素，将他与第0个位置的数据交换，然后将剩余数据按照这个方式的进行交换，直到数组正确排序</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;void SelectionSort(int a[], int size)&#123;    for (int i &#x3D; 0; i &lt; size - 1; ++i) &#123;        int tmpMin &#x3D; i;        for (int j &#x3D; i+1; j &lt; size; ++j) &#123;            if (a[j] &lt; a[tmpMin])&#123;                tmpMin &#x3D; j;            &#125;        &#125;        int tmp &#x3D; a[i];        a[i] &#x3D; a[tmpMin];        a[tmpMin] &#x3D; tmp;    &#125;&#125;int main()&#123;    int arr[10] &#x3D; &#123;12, 32, 13, 65, 35, 15, 45, 87, 56, 24&#125;;    int len &#x3D; sizeof(arr)&#x2F;sizeof(int);    SelectionSort(arr, len);    for (int i &#x3D; 0; i &lt; len; ++i) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;void swap1(int &amp;a, int &amp;b)&#123;    int temp;    temp &#x3D; a;    a &#x3D; b;    b &#x3D; temp;&#125;int main()&#123;    int arr[10] &#x3D; &#123;12, 32, 13, 65, 35, 15, 45, 87, 56, 24&#125;;    int len &#x3D; sizeof(arr)&#x2F;sizeof(int);    for (int i &#x3D; 0; i &lt; len; ++i) &#123;        for (int j &#x3D; i+1; j &lt; len; ++j) &#123;            if(arr[i] &gt; arr[j])&#123;                swap1(arr[i], arr[j]);            &#125;        &#125;    &#125;    for (int i &#x3D; 0; i &lt; len; ++i) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul><li>将整个数组分为有序的部分和无序的两个部分。前者在左边，后者在右边。</li><li>开始有序的部分只有第一个元素，其余都属于无序的部分。</li><li>每次取出无序部分的最左边的元素，将它加入到有序部分。</li><li>直到无序的部分没有元素。<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;void InsertionSort(int a[], int size)&#123;    for (int i &#x3D; 1; i &lt; size; ++i) &#123;        for (int j &#x3D; 0; j &lt; i; ++j) &#123;            if(a[j] &gt; a[i])&#123;                int tmp &#x3D; a[i];                for (int k &#x3D; i; k &gt; j; --k) &#123;                    a[k] &#x3D; a[k-1];                &#125;                a[j] &#x3D; tmp;                break;            &#125;        &#125;    &#125;&#125;int main()&#123;    int arr[10] &#x3D; &#123;12, 32, 13, 65, 35, 15, 45, 87, 56, 24&#125;;    int len &#x3D; sizeof(arr)&#x2F;sizeof(int);    InsertionSort(arr, len);    for (int i &#x3D; 0; i &lt; len; ++i) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int arr[10] &#x3D; &#123;12, 32, 13, 65, 35, 15, 45, 87, 56, 24&#125;;    int len &#x3D; sizeof(arr) &#x2F; sizeof(int);    for (int i &#x3D; 1; i &lt; len; ++i) &#123;        int tmp &#x3D; arr[i];        for (int j &#x3D; 0; j &lt; i; ++j) &#123;            if (arr[j] &gt; arr[i])&#123;                for (int k &#x3D; i; k &gt; j; --k) &#123;                    arr[k] &#x3D; arr[k-1];                &#125;                arr[j] &#x3D; tmp;                break;            &#125;        &#125;    &#125;    for (int i &#x3D; 0; i &lt; len; ++i) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2></li><li>将整个数组分为有序的部分和无序的两个部分。</li><li>前者在右边，后者在左边 开始整个数组是无序的。</li><li>有序的部分没有元素 每次使无序部分最大的元素移动到有序部分第一个元素的左边（方法：相邻的依次比较，然后进行交换）。</li><li>直到无序的部分没有元素。<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;void BubbleSort(int a[], int size)&#123;    for (int i &#x3D; size-1; i &gt; 0; --i) &#123;        for (int j &#x3D; 0; j &lt; i; ++j) &#123;            if(a[j] &gt; a[j+1])&#123;                int tmp &#x3D; a[j];                a[j] &#x3D; a[j+1];                a[j+1] &#x3D; tmp;            &#125;        &#125;    &#125;&#125;int main()&#123;    int arr[10] &#x3D; &#123;12, 32, 13, 65, 35, 15, 45, 87, 56, 24&#125;;    int len &#x3D; sizeof(arr) &#x2F; sizeof(int);    BubbleSort(arr, len);    for (int i &#x3D; 0; i &lt; len; ++i) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;void swap1(int &amp;a, int &amp;b)&#123;    int temp;    temp &#x3D; a;    a &#x3D; b;    b &#x3D; temp;&#125;int main()&#123;    int arr[10] &#x3D; &#123;12, 32, 13, 65, 35, 15, 45, 87, 56, 24&#125;;    int len &#x3D; sizeof(arr) &#x2F; sizeof(int);    for (int i &#x3D; len - 1; i &gt; 0; --i) &#123;        for (int j &#x3D; 0; j &lt; i; ++j) &#123;            if(arr[j] &gt; arr[j+1])&#123;                swap1(arr[j], arr[j+1]);            &#125;        &#125;    &#125;    for (int i &#x3D; 0; i &lt; len; ++i) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态变量</title>
      <link href="2021/02/16/c-c/jing-tai-bian-liang/"/>
      <url>2021/02/16/c-c/jing-tai-bian-liang/</url>
      
        <content type="html"><![CDATA[<h2 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h2><p>定义在函数内部的变量叫做局部变量<br>定义在所有函数外面的变量叫做全局变量</p><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul><li>全局变量都是静态变量。局部变量定义时如果前面加了<code>static</code>关键字,则该变量也成为静态变量。</li><li>静态变量的存放地址，在整个程序运行期间，都是固定不变的。</li><li>如果未明确初始化，则静态变量会自动初始化成全0（每个<code>bit</code>都是0），局部非静态变量的值则随机。</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;void Func()&#123;    static int n &#x3D; 4;    cout &lt;&lt; n &lt;&lt; endl;  &#x2F;&#x2F;打印结果 4 5 6    ++ n;&#125;int main()&#123;    Func(); Func(); Func();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;void Func()&#123;    int n &#x3D; 4;    cout &lt;&lt; n &lt;&lt; endl; &#x2F;&#x2F;打印结果4 4 4    ++ n;&#125;int main()&#123;    Func(); Func(); Func();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>【注】</strong> 静态变量只初始化一次</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>将一段字符串的空格和标点全部去掉。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123;    char str[] &#x3D; &quot;Hello, Wold.&quot;;    char *p &#x3D; strtok(str, &quot; ,.&quot;);    while (p !&#x3D; NULL)&#123;        cout &lt;&lt; p &lt;&lt; endl; &#x2F;&#x2F;Hello                            &#x2F;&#x2F;Wold        p &#x3D; strtok(NULL, &quot; ,.&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针（2）</title>
      <link href="2021/02/14/c-c/c-zhi-zhen-2/"/>
      <url>2021/02/14/c-c/c-zhi-zhen-2/</url>
      
        <content type="html"><![CDATA[<h2 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h2><p>定义：<code>T ** p</code>;<br><code>p</code>是指向指针的指针，<code>p</code>指向的地方应该存放着应该类型为<code>T*</code>的指针。<br><code>*p</code>的类型是 <code>T *</code></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int **pp;    int *p;    int n &#x3D; 10;    p &#x3D; &amp;n;    pp &#x3D; &amp;p;    cout &lt;&lt; *(*pp) &lt;&lt; endl; &#x2F;&#x2F;打印结果：10    return 0;&#125;&#x2F;&#x2F; pp -&gt; p -&gt; 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指针和字符串"><a href="#指针和字符串" class="headerlink" title="指针和字符串"></a>指针和字符串</h2><p>字符串常量的类型就是<code>char*</code><br>字符数组名的类型也是<code>char*</code></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    char p[] &#x3D; &quot;Hello\n&quot;;    cout &lt;&lt; p;    char a[20];    char *pa &#x3D; a;    cin &gt;&gt; pa;    cout &lt;&lt; &quot;Hello &quot; &lt;&lt; pa;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注】：在C++11以后的标准，不再使用<code>char *p = &quot;Hello\n&quot;</code>。</p><h2 id="字符串操作库函数"><a href="#字符串操作库函数" class="headerlink" title="字符串操作库函数"></a>字符串操作库函数</h2><p><code>strcat()</code>： 将一个字符串连接到另一个字符串<br><code>strchr()</code>： 查找某字符在字符串中最先出现的位置<br><code>strrchr()</code>： 查找某字符在字符串中最后出现的位置<br><code>strstr()</code>： 求子串的位置<br><code>strcmp()</code>： 比较两个字符串的大小（大小写相关）<br><code>stricmp()</code>： 比较两个字符串的大小（大小写无关）<br><code>strcpy()</code>： 字符串拷贝<br><code>strlen()</code>： 求字符串长度<br><code>strlwr()</code>： 将字符串变成小写<br><code>strupr()</code>： 将字符串变成大写<br><code>strncat()</code>： 将一个字符串的前n个字符连接到另一个字符串后面<br><code>strncmp()</code>： 比较两个字符串的前n个字符<br><code>strncpy()</code>： 拷贝字符串的前n个字符<br><code>strtok()</code>： 抽取被指定字符分隔的子串</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123;    char s1[10] &#x3D; &quot;12345&quot;;    char s2[10] &#x3D; &quot;abcde&quot;;    strncat(s1, s2, 3);    cout &lt;&lt; s1 &lt;&lt; endl; &#x2F;&#x2F;打印结果：12345abc    strncpy(s1, s2, 3);    cout &lt;&lt; s1 &lt;&lt; endl; &#x2F;&#x2F;打印结果：abc45abc    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h2><p><code>void</code>指针：<code>void *p</code>;<br>可以用任何类型的指针<code>void</code>指针进行赋值<br>因为<code>sizeof(void)</code>没有定义，所以相对于<code>void*</code>类型的指针<code>p</code>，<code>*p</code>无定义</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>通过指针变量调用函数，指向函数的指针变量称为“函数指针”。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;void PrintMin(int a, int b)&#123;    if(a &lt; b)&#123;        cout &lt;&lt; a;    &#125;else&#123;        cout &lt;&lt; b;    &#125;&#125;int main()&#123;    void(*pm)(int, int);    int x &#x3D; 4, y &#x3D; 5;    pm &#x3D; PrintMin;    pm(x,y);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针（1）</title>
      <link href="2021/02/07/c-c/c-zhi-zhen-1/"/>
      <url>2021/02/07/c-c/c-zhi-zhen-1/</url>
      
        <content type="html"><![CDATA[<h2 id="指针的概念"><a href="#指针的概念" class="headerlink" title="指针的概念"></a>指针的概念</h2><p>每个变量都被存放在从某个内存地址（以字节为单位）开始的若干个字节中。“指针”表示一个内存地址，通过指正，对其指向的内存区域进行读写。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char *p &#x3D; &amp;c;&#x2F;&#x2F; &amp;: 取地址运算符   &amp;x: 变量x的地址（即指向x的指针）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="指针的作用"><a href="#指针的作用" class="headerlink" title="指针的作用"></a>指针的作用</h2><p>有了指针，就有了自由访问内存空间的手段 不需要通过变量，就能对内存直接进行操作。如果<code>指针p</code>指向<code>x</code>,只需要对<code>p</code>进行加减操作，就能够访问<code>x</code>前后的内存区域。<br><strong>【注】</strong>：不同类型的指针不能直接相互赋值，需要经过强制类型转换。</p><h2 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h2><ul><li>两个相同类型的指针可以比较大小</li><li>两个同类型的指针变量可以相加减。<code>p1 - p2 = (地址p1 - 地址p2) / sizeof(T)</code></li><li>指针变量加减一个整数的结果是指针。 <code>p + n = 地址p + n * sizeof(T)</code></li><li>指针可以用下标运算符<code>[]</code>表示。 <code>p[n] 等价于 *(p+n)</code><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int *p1, *p2;    p1 &#x3D; (int *) 200;    p2 &#x3D; (int *) 100;    cout &lt;&lt; p1 - p2 &lt;&lt; endl; &#x2F;&#x2F; 打印结果：25    int n &#x3D; 4;    cout &lt;&lt; p1 + n - p2 &lt;&lt; endl; &#x2F;&#x2F;打印结果：29    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>指向地址0的指针就是空指针，但地址0不能访问。(可以使用关键字<code>NULL</code>，<code>NULL</code>就是整数0)</p><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><h3 id="指针和数组之间的关系"><a href="#指针和数组之间的关系" class="headerlink" title="指针和数组之间的关系"></a>指针和数组之间的关系</h3><ul><li>数组的名字是一个指针常量，指向数组的起始地址</li><li>作为函数形参时，<code>T *p</code> 和 <code>T p[]</code> 等价</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>交换数组的顺序</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;void Reverse(int *p, int size)&#123;    for (int i &#x3D; 0; i &lt; size&#x2F;2; ++i) &#123;        int tmp &#x3D; p[i];        p[i] &#x3D; p[size-1-i];        p[size-1-i] &#x3D; tmp;    &#125;&#125;int main()&#123;    int a[5] &#x3D; &#123;1, 2, 3, 4, 5&#125;;    Reverse(a, sizeof(a)&#x2F;sizeof(int));    for (int i &#x3D; 0; i &lt; 5; ++i) &#123;        cout &lt;&lt; *(a+i) &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++字符串</title>
      <link href="2021/02/01/c-c/c-zi-fu-chuan/"/>
      <url>2021/02/01/c-c/c-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串的三种形式"><a href="#字符串的三种形式" class="headerlink" title="字符串的三种形式"></a>字符串的三种形式</h2><ul><li>用双引号括起来的字符串常量</li><li>存放于字符数组中，以’\0’字符(ASCII为0)结尾</li><li><code>String</code>对象。<code>string</code>是C++标准模板中的一个类</li></ul><p>字符串常量占据内存的字节数等于字符串中字符数目加1(多出来的加1是’\0’)，但字符串的长度不包括’\0’。其中，<code>char[]</code>表示字符串数组。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123;    char a[100];    char b[100];    scanf(&quot;%s&quot;, a); &#x2F;&#x2F;输入字符串变量时不要加&amp;,&amp;指向的是地址    if(strcmp(a, &quot;Hello&quot;) &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;字符串比较函数        cout &lt;&lt; a;    &#125; else&#123;        strcpy(b, &quot;err&quot;); &#x2F;&#x2F;字符串拷贝函数        cout &lt;&lt; b;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h2><p>在C++中有<code>cin</code>和<code>scanf</code>两种输入方式，但在字符串输入的时候，无论是<code>cin</code>还是<code>scanf</code>的时候都会发现一个问题，输入空格以后，字符串就会停止输入。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using  namespace std;int main()&#123;    char a[100]; char b[100];    cin &gt;&gt; a;  &#x2F;&#x2F;输入：Hello World    cout &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F;打印结果：Hello    scanf(&quot;%s&quot;, b); &#x2F;&#x2F;输入：Hello World    cout &lt;&lt; b &lt;&lt; endl; &#x2F;&#x2F;打印结果：Hello    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了解决能够读入一行到字符数组中，我们使用<code>cin.getline(char buf[], int bufSize)</code>。其中<code>char buf[]</code>是需要输入的字符数组，<code>int bufSize</code>是字符数组的最大输入长度。当输入的最大长度是时候，则会停止输入。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    char line[10];    cin.getline(line, sizeof(line)); &#x2F;&#x2F;输入Hello World    cout &lt;&lt; line; &#x2F;&#x2F;打印结果为：Hello Wor    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道<code>cin</code>和<code>scanf</code>不能同时用，如果既想要输入一行，又想要使用<code>scanf</code>加快速度时，我们可以选择<code>gets(char buf[])</code>。<br>其中回车换行符不会写入<code>buf</code>中，但是会从输入流中去掉。有可能导致数组越界。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    char s[10];    gets(s); &#x2F;&#x2F;输入Hello World    printf(&quot;%s\n&quot;, s);&#x2F;&#x2F;打印结果：Hello World    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul><li><p>使用字符串函数需要#include<cstring></p></li><li><p>字符串函数都根据’\0’来判断字符串结尾</p></li><li><p>形参为char[]类型，则实参可以是char数组或字符串常量</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">字符串拷贝：strcpy(char[] dest, char[] src); &#x2F;&#x2F;拷贝src到dest字符串比较大小：int strcmp(char[] s1, char[] s2);&#x2F;&#x2F;返回0则相等求字符串长度：int strlen(char[] s);&#x2F;&#x2F;不算结尾的&#39;\0&#39;字符串拼接：strcat(char[] s1, char[] s2);&#x2F;&#x2F;s2拼接到s1后面字符串转成大写：strupr(char[]);字符串转成小写：strlwr(char[]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="strlen常见的糟糕用法"><a href="#strlen常见的糟糕用法" class="headerlink" title="strlen常见的糟糕用法"></a>strlen常见的糟糕用法</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char s[100] &#x3D; &quot;test&quot;;for(int i &#x3D; 0; i &lt; strlen(s); ++i)&#123;    s[i] &#x3D; s[i] + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这一段代码并没有任何错误，但会影响程序的效率。</p></li><li><p>strlen函数的执行是需要时间的，且时间和字符串的长度成正比</p></li><li><p>每次循环，都调用strlen函数，这是效率上的很大浪费</p></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="编写判断子串的函数"><a href="#编写判断子串的函数" class="headerlink" title="编写判断子串的函数"></a>编写判断子串的函数</h3><p><strong>如果s2不是s1的子串，返回-1</strong><br><strong>如果s2是s1是子串返回其s1第一次出现的位置</strong><br><strong>空串是任何串的子串，且出现位置为0</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int Strstr(char s1[], char s2[])&#123;    if (s2[0] &#x3D;&#x3D; 0)&#123;        return 0;    &#125;    for (int i &#x3D; 0; s1[i] ; ++i) &#123;        int k &#x3D; i, j &#x3D; 0;        for (; s2[j] ; ++j, ++k) &#123;            if (s1[k] !&#x3D; s2[j])&#123;                break;            &#125;        &#125;        if (s2[j] &#x3D;&#x3D; 0)&#123;            return 0;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的算法例题</title>
      <link href="2021/01/30/c-c/shu-zu-de-suan-fa-li-ti/"/>
      <url>2021/01/30/c-c/shu-zu-de-suan-fa-li-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="筛法求素数-100以内的素数"><a href="#筛法求素数-100以内的素数" class="headerlink" title="筛法求素数(100以内的素数)"></a>筛法求素数(100以内的素数)</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;#define num 100int isPrime[num + 5];int main()&#123;    for (int i &#x3D; 2; i &lt;&#x3D; num; ++i) &#123;        isPrime[i] &#x3D; 1;  &#x2F;&#x2F;将数组的所有数据假设为1    &#125;    for (int i &#x3D; 2; i &lt;&#x3D; num; ++i) &#123;        if (isPrime[i] &#x3D;&#x3D; 1) &#123;            for (int j &#x3D; 2 * i; j &lt;&#x3D; num; j +&#x3D; i) &#123;                isPrime[j] &#x3D; 0; &#x2F;&#x2F;将数组中不是素数的数据标记为0            &#125;        &#125;    &#125;    for (int i &#x3D; 2; i &lt;&#x3D; num; ++i) &#123;        if (isPrime[i] &#x3D;&#x3D; 1)&#123;            cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#x2F;&#x2F;输出所有数据为1的数组下标        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="判断星期几"><a href="#判断星期几" class="headerlink" title="判断星期几"></a>判断星期几</h2><p><strong>已知2012年1月25日是星期三，编写一个程序输入一个2012年1月25日后的日期，输出该日期是星期几（星期天输出0）</strong><br>分析2012年1月25日是星期三，那么2012年1月22日是星期日</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;输入形式：2012 03 06#include &lt;iostream&gt;using namespace std;int main()&#123;    int month_days[13] &#x3D; &#123;-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;    int year, month, day;    cin &gt;&gt; year &gt;&gt; month &gt;&gt; day;    for (int i &#x3D; 2012; i &lt; year; ++i) &#123;        if(i % 4 &#x3D;&#x3D; 0 &amp;&amp; i % 100 !&#x3D; 0 || i % 400 &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;判断是不是闰年            day +&#x3D; 366;        &#125; else&#123;            day +&#x3D; 365;        &#125;    &#125;    if(year % 4 &#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D; 0 || year % 400 &#x3D;&#x3D; 0)&#123;        month_days[2] &#x3D; 29;    &#125;    for (int i &#x3D; 1; i &lt; month; ++i) &#123;        day +&#x3D; month_days[i];    &#125;    day -&#x3D; 22;    cout &lt;&lt; day % 7;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;输入形式：&#x2F;&#x2F;2 3&#x2F;&#x2F;1 1 1&#x2F;&#x2F;1 1 1&#x2F;&#x2F;3 3&#x2F;&#x2F;1 1 1&#x2F;&#x2F;1 1 1&#x2F;&#x2F;1 1 1#include &lt;iostream&gt;using namespace std;int main()&#123;    int m, n, q, w;    cin &gt;&gt; m &gt;&gt; n;    int a[m][n];    for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;        for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;            cin &gt;&gt; a[i][j];        &#125;    &#125;    cin &gt;&gt; q &gt;&gt; w;    int b[q][w];    for (int i &#x3D; 1; i &lt;&#x3D; q; ++i) &#123;        for (int j &#x3D; 1; j &lt;&#x3D; w; ++j) &#123;            cin &gt;&gt; b[i][j];        &#125;    &#125;    int c[100][100];    for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;        for (int j &#x3D; 1; j &lt;&#x3D; w; ++j) &#123;            c[i][j] &#x3D; 0;            for (int k &#x3D; 1; k &lt;&#x3D; n; ++k) &#123;                c[i][j] +&#x3D; a[i][k] * b[k][j];            &#125;        &#125;    &#125;    for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;        for (int j &#x3D; 1; j &lt;&#x3D; w; ++j) &#123;            cout &lt;&lt; c[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的算法例题</title>
      <link href="2021/01/30/c-c/han-shu-de-suan-fa-li-ti/"/>
      <url>2021/01/30/c-c/han-shu-de-suan-fa-li-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="判断是不是素数"><a href="#判断是不是素数" class="headerlink" title="判断是不是素数"></a>判断是不是素数</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;bool IsPrime(int n)&#123;    if(n &lt;&#x3D; 1) return false;    for (int i &#x3D; 2; i &lt; n; ++i) &#123;        if(n % i &#x3D;&#x3D; 0)&#123;            return false;        &#125;        return true;    &#125;&#125;int main()&#123;    int num;    cin &gt;&gt; num;    cout &lt;&lt; IsPrime(num);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="求三条边的长度"><a href="#求三条边的长度" class="headerlink" title="求三条边的长度"></a>求三条边的长度</h2><p><strong>已知三个点的坐标，求三角形的三条边的长度</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;#define EPS 0.001double Sqrt(double a)&#123; &#x2F;&#x2F;牛顿迭代法    double x &#x3D; a &#x2F; 2, lastX &#x3D; x + 1 + EPS;    while (x - lastX &gt; EPS || lastX - x &gt; EPS)&#123;        lastX &#x3D; x;        x &#x3D; (x + a&#x2F;x) &#x2F; 2;    &#125;    return x;&#125;double Distance(double x1, double y1, double x2, double y2)&#123;    return Sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));&#125;int main()&#123;    int x1, y1, x2, y2, x3, y3;    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3;    cout &lt;&lt; Distance(x1, y1, x2, y2) &lt;&lt; endl;    cout &lt;&lt; Distance(x1, y1, x3, y3) &lt;&lt; endl;    cout &lt;&lt; Distance(x3, y3, x2, y2) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="将数组中所有元素置为0"><a href="#将数组中所有元素置为0" class="headerlink" title="将数组中所有元素置为0"></a>将数组中所有元素置为0</h2><p>说明：这两个算法只是想要展现，当形参是数组的时候，形参是可以改变实参的值。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;void Swap(int a, int b)&#123;    int c;    c &#x3D; a;    a &#x3D; b;    b &#x3D; c;    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123;    int a &#x3D; 3, b &#x3D; 4;    Swap(a, b);    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int a[4] &#x3D; &#123;3, 4, 5, 6&#125;;void SetToZore(int x[])&#123;    for (int i &#x3D; 0; i &lt; 4; ++i) &#123;        x[i] &#x3D; 0;    &#125;&#125;int main()&#123;    SetToZore(a);    for (int i &#x3D; 0; i &lt; 4; ++i) &#123;        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++循环</title>
      <link href="2021/01/27/c-c/c-xun-huan/"/>
      <url>2021/01/27/c-c/c-xun-huan/</url>
      
        <content type="html"><![CDATA[<h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>只要条件为真，<code>while</code>语句就能重复地执行循环体。<br><strong>语法形式为：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">while(condition)&#123;  &#x2F;&#x2F;只要condition的值为真，就能一直执行    statement&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>【注】</strong>:当不清楚要迭代多少次的时候，最好使用<code>while</code>循环。</p><h2 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h2><p><code>do while</code>语句和<code>while</code>语句相似，唯一区别是<code>do while</code>语句先执行循环体后再进行检查条件。因此不管怎么样，<code>do while</code>都至少会执行一次循环。<br><strong>语法形式为：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">do    statementwhile(condition);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p><strong>语法形式为：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for(init-statement; condition; expression)    statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>for</code>循环语句头中的<code>init-statement</code>,<code>condition</code>,<code>expression</code>可以都为空，但是分号必须保留。当这三者都为空时，程序将陷入死循环，但是可以通过<code>break</code>跳出。</p><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><p>可以出现在任意的循环体中，其作用是跳出循环。在多重循环的情况下，<code>break</code>只能跳出直接包含它的那一重循环。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int n &#x3D; 0;    while (true)&#123;        if (n &gt; 100)&#123;            break;        &#125;        ++n;    &#125;    cout &lt;&lt; n; &#x2F;&#x2F;打印结果：101    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>终止最近的循环中的当前迭代并立即开始下一次迭代。（也就是立即终止本次循环，开始下一次循环）。<br><code>continue</code>在多重循环里和<code>break</code>一致，<code>continue</code>只对自己包含它的那一重循环起作用。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    for (int i &#x3D; 1; i &lt;&#x3D; 10; ++i) &#123;        if (i % 2)            continue;        cout &lt;&lt; i &lt;&lt; endl; &#x2F;&#x2F;打印结果：2,4,6,8,10    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例：输入正整数n(n&gt;=2),求不大于n的全部质数。</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    cout &lt;&lt; 2 &lt;&lt; endl;    for (int i &#x3D; 3; i &lt;&#x3D; n; i +&#x3D; 2) &#123;        int k;        for (k &#x3D; 3; k &lt; i; k +&#x3D; 2) &#123;            if(i % k &#x3D;&#x3D; 0)&#123;                break;            &#125;            if (k * k &gt; i) &#123;                break;            &#125;        &#125;        if(k*k &gt; i)&#123;            cout &lt;&lt; i &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Switch语句</title>
      <link href="2021/01/27/c-c/switch-yu-ju/"/>
      <url>2021/01/27/c-c/switch-yu-ju/</url>
      
        <content type="html"><![CDATA[<p><code>switch</code>语句提供了一个便利的途径，让我们在若干个固定的选项中做出选择，解决了代码中出现大量的<code>else if</code>问题。</p><h2 id="Switch语句的写法"><a href="#Switch语句的写法" class="headerlink" title="Switch语句的写法"></a>Switch语句的写法</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">switch(表达式)&#123; &#x2F;&#x2F;表达式的值必须是整数类型(int,char...)    case 常量表达式1: &#x2F;&#x2F;常量表达式必须是整数类型的常量(int,char...)        语句组1        break;    case 常量表达式2:        语句组2        break;    .....    case 常量表达式3:        语句组3    break;    default:        语句组n+1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>switch</code>语句对表达式进行判断，如果表达式的值等于常量表达式的值，则执行对应的语句组，进而执行<code>break</code>。程序在执行完<code>break</code>后，执行<code>default</code>及<code>default</code>对应的语句组。</p><p><strong>【注】</strong></p><ul><li>如果没有写<code>break</code>，则不会直接跳转到<code>default</code>，程序会依次进行运行，直到<code>switch</code>语句运行结束。（至少需要写一个<code>break</code>，不然易引发缺陷，造成代码错误）。</li><li><code>default</code>可以不写，但是如果<code>switch</code>语句的表达式和常量表达式没有一个是对应的，则程序中的<code>switch</code>语句相当于没有运行。</li></ul><p><strong>例子:</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    switch (n) &#123;        case 1:            printf(&quot;Monday&quot;);            break;        case 2:            printf(&quot;Tuesday&quot;);            break;        case 3:            printf(&quot;Wednesday&quot;);            break;        case 4:            printf(&quot;Thursday&quot;);            break;        case 5:            printf(&quot;Friday&quot;);            break;        case 6:            printf(&quot;Saturday&quot;);            break;        case 7:            printf(&quot;Sunday&quot;);            break;        default:            printf(&quot;Illegal&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++输入输出和算术运算</title>
      <link href="2021/01/24/c-c/c-shu-ru-shu-chu-he-suan-zhu-yun-suan/"/>
      <url>2021/01/24/c-c/c-shu-ru-shu-chu-he-suan-zhu-yun-suan/</url>
      
        <content type="html"><![CDATA[<h2 id="C-的输入输出"><a href="#C-的输入输出" class="headerlink" title="C++的输入输出"></a>C++的输入输出</h2><p>C++具有两种输入和输出的运算形式，分别为<code>cin</code>、<code>scanf</code>（输入）和<code>cout</code>、<code>printf</code>（输出）。</p><h3 id="cin和cout形式"><a href="#cin和cout形式" class="headerlink" title="cin和cout形式"></a>cin和cout形式</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;int main()&#123;    int c;    while ((c &#x3D; cin.get()) !&#x3D; EOF)&#123;        &#x2F;&#x2F;cin.get()的返回值是int,故需要强转        cout &lt;&lt; (char)c;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int sum &#x3D; 0, value &#x3D; 0;    while (cin &gt;&gt; value)&#123;        sum +&#x3D; value;    &#x2F;&#x2F;将输入的数据累加到一起    &#125;    cout &lt;&lt; sum;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="scanf和printf形式"><a href="#scanf和printf形式" class="headerlink" title="scanf和printf形式"></a>scanf和printf形式</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123;    char c;    while (scanf(&quot;%c&quot;, &amp;c) !&#x3D; EOF)&#123;        printf(&quot;%c&quot;, c);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>强调</strong>：</p><ul><li>输入流中不存在<code>EOF</code>，<code>EOF</code>是表示没有数据再进行输入了。</li><li><code>cin</code>和<code>cout</code>的速度比<code>scanf</code>和<code>printf</code>速度慢，输入、输出数据量较大时，建议用后者。</li><li>一个程序中不要同时使用<code>cin</code>和<code>scanf</code>，也不要同时使用<code>cout</code>和<code>printf</code>。</li></ul><h2 id="C-的算术运算"><a href="#C-的算术运算" class="headerlink" title="C++的算术运算"></a>C++的算术运算</h2><h3 id="运算的精度"><a href="#运算的精度" class="headerlink" title="运算的精度"></a>运算的精度</h3><p>做算术运算的时候，表达式结果的值的类型，以精度高的为准。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int a &#x3D; 1;    double b &#x3D; 1.2;    cout &lt;&lt; a+b; &#x2F;&#x2F;打印结果为：2.2    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>精度大小比较：double &gt; long long &gt; int &gt; short &gt; char</p><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>在运算时，有可能出现数据过大，造成溢出现象发生。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    printf(&quot;%d\n&quot;, (2147483646 + 6)&#x2F;2); &#x2F;&#x2F;打印结果：-1073741822    printf(&quot;%d&quot;, 2147483646&#x2F;2 + 6&#x2F;2);&#x2F;&#x2F;打印结果：1073741826    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决溢出的最好的办法就是使用更高精度的数据类型</p><h3 id="自增运算符"><a href="#自增运算符" class="headerlink" title="自增运算符(++)"></a>自增运算符(++)</h3><ul><li>前置用法：++a； 将a的值加1，表达式的返回值为a加1后的值（先自加再返值）</li><li>后置用法：a++； 将a的值加1，表达式的返回值为a加1前的值（先返值再自加）</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;int main()&#123;    int n1 &#x3D; 5, n2 &#x3D; 6;    n1 &#x3D; n2 ++;    cout &lt;&lt; n1 &lt;&lt; &quot;,&quot; &lt;&lt; n2 &lt;&lt; endl; &#x2F;&#x2F;打印结果：6，7    n1 &#x3D; ++ n2;    cout &lt;&lt; n1 &lt;&lt; &quot;,&quot; &lt;&lt; n2 &lt;&lt; endl;&#x2F;&#x2F;打印结果：8,8    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：自减和自增同理。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
